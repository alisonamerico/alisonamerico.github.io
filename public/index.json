{"categories":[{"link":"/categories/testing/","name":"Testing","slug":"Testing"}],"pages":[],"posts":[{"link":"/posts/testing-with-pytest-fundamentals-best-practices-and-strategy/","text":" Testing software is not just a technical development step, it\u0026rsquo;s a quality, confidence, and sustainability strategy. Systems without tests tend to break frequently, create fear of changes, and drastically increase maintenance costs.\nIn this post, we\u0026rsquo;ll focus 100% on theory, explaining fundamental concepts of automated testing using Pytest, the most popular testing framework in the Python ecosystem.\nüëâ In the next post of the series, we\u0026rsquo;ll apply all of this to a real Flask project consuming the GitHub public API.\nWhat is Pytest? Pytest is a testing framework for Python that makes it easy to create simple, readable, and scalable tests. It allows testing from isolated functions to complete systems.\nWhy is Pytest so widely used? Simple syntax (based on assert) Automatic test discovery Powerful fixtures system Excellent plugin support Scales well for large projects Compared to unittest, Pytest is more expressive, less verbose, and more productive.\nWhat is the purpose of tests? Tests exist to reduce uncertainty.\nThey help to:\nEnsure code works as expected Detect errors quickly Prevent regressions Enable safe refactoring Serve as living documentation of the system Code without tests might work today, but it\u0026rsquo;s fragile tomorrow.\nWhen to write tests? When creating new features When fixing bugs (especially regressions) Before refactoring existing code In business-critical code And when NOT to write tests? Very quick proofs of concept (POCs) Completely disposable scripts Even in these cases, tests can still bring benefits.\nTypes of Tests Understanding test types is essential to create a balanced strategy.\nUnit Tests Test isolated functions or methods Don\u0026rsquo;t access database, network, or file system Are fast and cheap ‚úîÔ∏è Foundation of the test pyramid\nIntegration Tests Test communication between components Example: application + database, application + external API ‚úîÔ∏è Detect real integration failures ‚ùå Slower\nFunctional Tests Test complete application flows Simulate user behavior ‚úîÔ∏è High confidence ‚ùå More complex\nSystem / End-to-End (E2E) Tests Test the system as a whole Include multiple layers ‚úîÔ∏è Simulate real usage ‚ùå Slow and fragile\nRegression Tests Ensure fixed bugs don\u0026rsquo;t come back Usually arise after real incidents ‚úîÔ∏è Protect against recurring errors\nPerformance Tests Evaluate response time and resource consumption Identify bottlenecks ‚úîÔ∏è Important in critical systems ‚ùå Should be used with discretion\nThe Test Pyramid A good testing strategy follows the pyramid:\nMany unit tests Some integration tests Few E2E tests This ensures speed, confidence, and controlled cost.\nThe AAA Pattern (Arrange, Act, Assert) AAA is a test organization pattern that dramatically improves readability.\nArrange Prepare data, mocks, and context.\nAct Execute the action being tested.\nAssert Validate the result.\nBenefits Clearer tests Less ambiguity Easier maintenance Fixtures in Pytest Fixtures are reusable functions responsible for preparing and cleaning up the test environment.\nWhy use fixtures? Avoid code duplication Centralize setup/teardown Make tests more readable Fixture scopes function: default (runs for each test) module: once per file session: once per execution Pytest Marks Marks allow you to classify and control tests.\nparametrize Allows running the same test with multiple data sets.\nBenefits:\nLess code More coverage More expressive tests skip Consciously ignores tests.\nWhen to use:\nUnavailable external dependency Disabled functionality xfail Marks tests that should fail.\nBenefits:\nDocuments known bugs Doesn\u0026rsquo;t break the pipeline slow Marks slow tests.\nBenefits:\nSelective execution Quick feedback in daily work What is Mock? Mock is a technique used to simulate external dependencies.\nWhen to use mock? External APIs Database Third-party services When NOT to use? To test internal logic Excessively (overmocking) unittest.mock vs pytest-mock unittest.mock Python standard library More verbose Uses context managers ‚úîÔ∏è Doesn\u0026rsquo;t depend on plugins ‚ùå Code harder to read\npytest-mock Pytest plugin Integration with fixtures Cleaner syntax ‚úîÔ∏è More productive ‚úîÔ∏è More readable\nEssential Pytest Plugins pytest-cov Measures code coverage Helps identify untested areas ‚ö†Ô∏è High coverage ‚â† quality code\npytest-mock Facilitates mock creation Reduces boilerplate General Best Practices Tests should be simple One behavior per test Clear and descriptive names Avoid complex logic in tests Tests should be deterministic Conclusion Automated tests are not a luxury, they are a professional necessity. Pytest provides the right tools to write clear, scalable, and reliable tests.\nIn the next post of the series, we\u0026rsquo;ll apply all these concepts in a real Flask project, consuming the GitHub public API, with unit, integration, functional, and performance tests.\nüëâ Continue to Post 2: Pytest in Practice with Flask and GitHub API\n","title":"Testing with Pytest - Fundamentals, Best Practices and Strategy"},{"link":"/posts/understanding-mock-and-magicmock-in-python/","text":" This article was written so anyone can understand it (if there is anything unclear, let me know so it can be improved), even if you are just getting started with testing in Python.\nWe will explain what each concept is, why it exists, and when to use it, always with practical examples and clear explanations.\n1. What is a Mock? (simple explanation) A Mock is a fake object, created only for tests, that pretends to be a real object.\nIt allows you to:\nSimulate functions, methods, classes, and entire objects Define return values and exceptions Record calls (count, arguments, order) Isolate the unit of code under test Instead of using:\na real database, an external API, an email service, or a complex system, we use a mock to simulate this behavior.\nWhy is this important? Because in tests we want:\nspeed, predictability, isolation. Mental example Imagine a function that sends emails:\nPYTHON Collapse Copy def send_email(to): print(\u0026#34;Sending email\u0026#34;) Click to expand and view more In a test, you do not want to send real emails. So you replace this function with a mock.\nThe mock:\nsends nothing, but records whether it was called, with which arguments, and how many times. üëâ That is why we say a mock is flexible: you define how it should behave.\nüëâ Any attribute accessed on a Mock automatically becomes another Mock.\n2. What is MagicMock? MagicMock is a special type and subclass of Mock.\nIt exists to simulate objects that use Python magic methods.\nWhat are magic methods? They are methods that:\nstart and end with __ are called automatically by Python Common examples:\n__len__ ‚Üí called when using len(obj) __iter__ ‚Üí used in for loops __getitem__ ‚Üí used with obj[x] __contains__ ‚Üí used with in __str__ ‚Üí used with print(obj) These methods are not called directly, but by Python itself.\nWhy does MagicMock exist? A regular Mock does not handle these methods well. MagicMock is already prepared for them.\n3. Mock ‚â† Stub ‚â† Fake (important differences) Stub A stub only returns fixed values.\nPYTHON Collapse Copy def get_user_stub(): return {\u0026#34;id\u0026#34;: 1} Click to expand and view more Fake A fake has a simple but functional implementation.\nPYTHON Collapse Copy class FakeEmailService: def __init__(self): self.sent = [] def send(self, to): self.sent.append(to) Click to expand and view more Mock A mock records calls and validates interactions.\nPYTHON Collapse Copy from unittest.mock import Mock email = Mock() email.send(\u0026#34;a@test.com\u0026#34;) email.send.assert_called_once_with(\u0026#34;a@test.com\u0026#34;) Click to expand and view more 4. Main attributes and methods return_value Defines the value returned by the mock.\nPYTHON Collapse Copy mock.func.return_value = 10 Click to expand and view more side_effect Allows exceptions, functions, or multiple return values.\nPYTHON Collapse Copy mock.func.side_effect = Exception(\u0026#34;Error\u0026#34;) Click to expand and view more called / call_count Indicate whether and how many times it was called.\nPYTHON Collapse Copy assert mock.func.called assert mock.func.call_count == 1 Click to expand and view more call_args / call_args_list Show the arguments used.\nPYTHON Collapse Copy mock.func(1) mock.func(2) assert mock.func.call_args_list == [((1,),), ((2,),)] Click to expand and view more 5. patch ‚Äî replacing dependencies Use patch to temporarily replace real dependencies with mocks.\nGolden rule:\nYou must patch where the object is USED, not where it is DEFINED.\nPYTHON Collapse Copy # app/services.py from app.email import send_email def notify(user): send_email(user.email) Click to expand and view more PYTHON Collapse Copy with patch(\u0026#34;app.services.send_email\u0026#34;) as mock_send: notify(user) Click to expand and view more ‚ùå WRONG:\nPYTHON Collapse Copy patch(\u0026#34;app.email.send_email\u0026#34;) Click to expand and view more 6. spec and autospec Use them to avoid silent errors and ensure correct signatures.\nspec Restricts valid attributes.\nPYTHON Collapse Copy mock = Mock(spec=MyClass) Click to expand and view more autospec Restricts attributes and the function signature.\nPYTHON Collapse Copy @patch(\u0026#34;module.func\u0026#34;, autospec=True) def test(mock_func): ... Click to expand and view more ‚úÖ Prevents silent errors.\n7. Mock with logic ‚Üí use Fake If a mock contains complex logic, turn it into a fake.\n8. Common problems and how to solve them ‚ùå Mock does not work ‚û°Ô∏è Patch applied in the wrong place\n‚ùå Test passes but breaks in production ‚û°Ô∏è Missing autospec\n‚ùå Test is hard to understand ‚û°Ô∏è Too many mocks\n‚ùå Mock with logic ‚û°Ô∏è Extract into a fake\n9. When to use (and when NOT to use) Use mocks when: There are HTTP calls There is database access There is file read/write There are external services There are hard-to-reproduce dependencies Do NOT use mocks when: You are testing pure logic The test becomes a copy of the implementation The mock starts having its own logic Practical rule: mock dependencies, not business rules.\n10. Real best practices Use autospec=True Mock less, test more behavior Name your mocks well One test, one scenario 11. Anti-patterns üö´ Mocking private methods\nüö´ Mocking domain logic\nüö´ Testing only calls\nüö´ Excessive nested mocks\n12. Mental checklist Before creating a mock:\nIs this an external dependency? Does this test really need it? Would a fake be simpler? Am I testing behavior or implementation? References https://docs.python.org/3/library/unittest.mock.html ","title":"Understanding Mock and MagicMock in Python"}],"tags":[{"link":"/tags/mock/","name":"Mock","slug":"Mock"},{"link":"/tags/pytest/","name":"Pytest","slug":"Pytest"},{"link":"/tags/python/","name":"Python","slug":"Python"},{"link":"/tags/tests/","name":"Tests","slug":"Tests"},{"link":"/tags/unittest/","name":"Unittest","slug":"Unittest"}]}