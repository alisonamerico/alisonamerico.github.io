{"categories":[{"link":"/categories/testing/","name":"Testing","slug":"Testing"}],"pages":[],"posts":[{"link":"/posts/understanding-mock-and-magicmock-in-python/","text":" This article was written so anyone can understand it (if there is anything unclear, let me know so it can be improved), even if you are just getting started with testing in Python.\nWe will explain what each concept is, why it exists, and when to use it, always with practical examples and clear explanations.\n1. What is a Mock? (simple explanation) A Mock is a fake object, created only for tests, that pretends to be a real object.\nIt allows you to:\nSimulate functions, methods, classes, and entire objects Define return values and exceptions Record calls (count, arguments, order) Isolate the unit of code under test Instead of using:\na real database, an external API, an email service, or a complex system, we use a mock to simulate this behavior.\nWhy is this important? Because in tests we want:\nspeed, predictability, isolation. Mental example Imagine a function that sends emails:\nPYTHON Collapse Copy def send_email(to): print(\u0026#34;Sending email\u0026#34;) Click to expand and view more In a test, you do not want to send real emails. So you replace this function with a mock.\nThe mock:\nsends nothing, but records whether it was called, with which arguments, and how many times. üëâ That is why we say a mock is flexible: you define how it should behave.\nüëâ Any attribute accessed on a Mock automatically becomes another Mock.\n2. What is MagicMock? MagicMock is a special type and subclass of Mock.\nIt exists to simulate objects that use Python magic methods.\nWhat are magic methods? They are methods that:\nstart and end with __ are called automatically by Python Common examples:\n__len__ ‚Üí called when using len(obj) __iter__ ‚Üí used in for loops __getitem__ ‚Üí used with obj[x] __contains__ ‚Üí used with in __str__ ‚Üí used with print(obj) These methods are not called directly, but by Python itself.\nWhy does MagicMock exist? A regular Mock does not handle these methods well. MagicMock is already prepared for them.\n3. Mock ‚â† Stub ‚â† Fake (important differences) Stub A stub only returns fixed values.\nPYTHON Collapse Copy def get_user_stub(): return {\u0026#34;id\u0026#34;: 1} Click to expand and view more Fake A fake has a simple but functional implementation.\nPYTHON Collapse Copy class FakeEmailService: def __init__(self): self.sent = [] def send(self, to): self.sent.append(to) Click to expand and view more Mock A mock records calls and validates interactions.\nPYTHON Collapse Copy from unittest.mock import Mock email = Mock() email.send(\u0026#34;a@test.com\u0026#34;) email.send.assert_called_once_with(\u0026#34;a@test.com\u0026#34;) Click to expand and view more 4. Main attributes and methods return_value Defines the value returned by the mock.\nPYTHON Collapse Copy mock.func.return_value = 10 Click to expand and view more side_effect Allows exceptions, functions, or multiple return values.\nPYTHON Collapse Copy mock.func.side_effect = Exception(\u0026#34;Error\u0026#34;) Click to expand and view more called / call_count Indicate whether and how many times it was called.\nPYTHON Collapse Copy assert mock.func.called assert mock.func.call_count == 1 Click to expand and view more call_args / call_args_list Show the arguments used.\nPYTHON Collapse Copy mock.func(1) mock.func(2) assert mock.func.call_args_list == [((1,),), ((2,),)] Click to expand and view more 5. patch ‚Äî replacing dependencies Use patch to temporarily replace real dependencies with mocks.\nGolden rule:\nYou must patch where the object is USED, not where it is DEFINED.\nPYTHON Collapse Copy # app/services.py from app.email import send_email def notify(user): send_email(user.email) Click to expand and view more PYTHON Collapse Copy with patch(\u0026#34;app.services.send_email\u0026#34;) as mock_send: notify(user) Click to expand and view more ‚ùå WRONG:\nPYTHON Collapse Copy patch(\u0026#34;app.email.send_email\u0026#34;) Click to expand and view more 6. spec and autospec Use them to avoid silent errors and ensure correct signatures.\nspec Restricts valid attributes.\nPYTHON Collapse Copy mock = Mock(spec=MyClass) Click to expand and view more autospec Restricts attributes and the function signature.\nPYTHON Collapse Copy @patch(\u0026#34;module.func\u0026#34;, autospec=True) def test(mock_func): ... Click to expand and view more ‚úÖ Prevents silent errors.\n7. Mock with logic ‚Üí use Fake If a mock contains complex logic, turn it into a fake.\n8. Common problems and how to solve them ‚ùå Mock does not work ‚û°Ô∏è Patch applied in the wrong place\n‚ùå Test passes but breaks in production ‚û°Ô∏è Missing autospec\n‚ùå Test is hard to understand ‚û°Ô∏è Too many mocks\n‚ùå Mock with logic ‚û°Ô∏è Extract into a fake\n9. When to use (and when NOT to use) Use mocks when: There are HTTP calls There is database access There is file read/write There are external services There are hard-to-reproduce dependencies Do NOT use mocks when: You are testing pure logic The test becomes a copy of the implementation The mock starts having its own logic Practical rule: mock dependencies, not business rules.\n10. Real best practices Use autospec=True Mock less, test more behavior Name your mocks well One test, one scenario 11. Anti-patterns üö´ Mocking private methods\nüö´ Mocking domain logic\nüö´ Testing only calls\nüö´ Excessive nested mocks\n12. Mental checklist Before creating a mock:\nIs this an external dependency? Does this test really need it? Would a fake be simpler? Am I testing behavior or implementation? References https://docs.python.org/3/library/unittest.mock.html ","title":"Understanding Mock and MagicMock in Python"}],"tags":[{"link":"/tags/mock/","name":"Mock","slug":"Mock"},{"link":"/tags/python/","name":"Python","slug":"Python"},{"link":"/tags/tests/","name":"Tests","slug":"Tests"},{"link":"/tags/unittest/","name":"Unittest","slug":"Unittest"}]}