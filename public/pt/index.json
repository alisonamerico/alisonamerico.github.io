{"categories":[{"link":"/pt/categories/testing/","name":"Testing","slug":"Testing"}],"pages":[],"posts":[{"link":"/pt/posts/testes-com-pytest-fundamentos-boas-pr%C3%A1ticas-e-estrat%C3%A9gia/","text":" Testar software n√£o √© apenas uma etapa t√©cnica do desenvolvimento √© uma estrat√©gia de qualidade, confian√ßa e sustentabilidade. Sistemas sem testes tendem a quebrar com frequ√™ncia, gerar medo de mudan√ßas e aumentar drasticamente o custo de manuten√ß√£o.\nNeste post, vamos focar 100% na teoria, explicando conceitos fundamentais de testes automatizados usando Pytest, o framework de testes mais popular do ecossistema Python.\nüëâ No pr√≥ximo post da s√©rie, aplicaremos tudo isso em um projeto Flask real consumindo a API p√∫blica do GitHub.\nO que √© Pytest? Pytest √© um framework de testes para Python que facilita a cria√ß√£o de testes simples, leg√≠veis e escal√°veis. Ele permite testar desde fun√ß√µes isoladas at√© sistemas completos.\nPor que Pytest √© t√£o usado? Sintaxe simples (baseada em assert) Descoberta autom√°tica de testes Sistema poderoso de fixtures Excelente suporte a plugins Escala bem para projetos grandes Comparado ao unittest, o Pytest √© mais expressivo, menos verboso e mais produtivo.\nQual √© o objetivo dos testes? Testes existem para reduzir incerteza.\nEles ajudam a:\nGarantir que o c√≥digo funciona como esperado Detectar erros rapidamente Evitar regress√µes Permitir refatora√ß√µes seguras Servir como documenta√ß√£o viva do sistema Um c√≥digo sem testes pode at√© funcionar hoje, mas √© fr√°gil amanh√£.\nQuando escrever testes? Ao criar novas funcionalidades Ao corrigir bugs (especialmente regress√µes) Antes de refatorar c√≥digo existente Em c√≥digo cr√≠tico para o neg√≥cio E quando N√ÉO escrever testes? Provas de conceito muito r√°pidas (POCs) Scripts totalmente descart√°veis Mesmo nesses casos, testes ainda podem trazer benef√≠cios.\nTipos de Testes Entender os tipos de testes √© essencial para criar uma estrat√©gia equilibrada.\nTestes Unit√°rios Testam fun√ß√µes ou m√©todos isolados N√£o acessam banco, rede ou sistema de arquivos S√£o r√°pidos e baratos ‚úîÔ∏è Base da pir√¢mide de testes\nTestes de Integra√ß√£o Testam a comunica√ß√£o entre componentes Exemplo: aplica√ß√£o + banco, aplica√ß√£o + API externa ‚úîÔ∏è Detectam falhas reais de integra√ß√£o ‚ùå Mais lentos\nTestes Funcionais Testam fluxos completos da aplica√ß√£o Simulam o comportamento do usu√°rio ‚úîÔ∏è Alta confian√ßa ‚ùå Mais complexos\nTestes de Sistema / End-to-End (E2E) Testam o sistema como um todo Incluem m√∫ltiplas camadas ‚úîÔ∏è Simulam uso real ‚ùå Lentos e fr√°geis\nTestes de Regress√£o Garantem que bugs corrigidos n√£o voltem Normalmente surgem ap√≥s incidentes reais ‚úîÔ∏è Protegem contra erros reincidentes\nTestes de Performance Avaliam tempo de resposta e consumo de recursos Identificam gargalos ‚úîÔ∏è Importantes em sistemas cr√≠ticos ‚ùå Devem ser usados com crit√©rio\nA Pir√¢mide de Testes Uma boa estrat√©gia de testes segue a pir√¢mide:\nMuitos testes unit√°rios Alguns testes de integra√ß√£o Poucos testes E2E Isso garante velocidade, confian√ßa e custo controlado.\nO padr√£o AAA (Arrange, Act, Assert) AAA √© um padr√£o de organiza√ß√£o de testes que melhora drasticamente a legibilidade.\nArrange Preparar dados, mocks e contexto.\nAct Executar a a√ß√£o que est√° sendo testada.\nAssert Validar o resultado.\nBenef√≠cios Testes mais claros Menos ambiguidade Manuten√ß√£o mais f√°cil Fixtures no Pytest Fixtures s√£o fun√ß√µes reutiliz√°veis respons√°veis por preparar e limpar o ambiente de testes.\nPor que usar fixtures? Evitam duplica√ß√£o de c√≥digo Centralizam setup/teardown Tornam os testes mais leg√≠veis Escopos de fixtures function: padr√£o (executa a cada teste) module: uma vez por arquivo session: uma vez por execu√ß√£o Pytest Marks Marks permitem classificar e controlar testes.\nparametrize Permite rodar o mesmo teste com v√°rios dados.\nBenef√≠cios:\nMenos c√≥digo Mais cobertura Testes mais expressivos skip Ignora testes conscientemente.\nQuando usar:\nDepend√™ncia externa indispon√≠vel Funcionalidade desativada xfail Marca testes que devem falhar.\nBenef√≠cios:\nDocumenta bugs conhecidos N√£o quebra o pipeline slow Marca testes lentos.\nBenef√≠cios:\nExecu√ß√£o seletiva Feedback r√°pido no dia a dia O que √© Mock? Mock √© uma t√©cnica usada para simular depend√™ncias externas.\nQuando usar mock? APIs externas Banco de dados Servi√ßos de terceiros Quando N√ÉO usar? Para testar l√≥gica interna Em excesso (overmocking) unittest.mock vs pytest-mock unittest.mock Biblioteca padr√£o do Python Mais verbosa Usa context managers ‚úîÔ∏è N√£o depende de plugins ‚ùå C√≥digo mais dif√≠cil de ler\npytest-mock Plugin do Pytest Integra√ß√£o com fixtures Sintaxe mais limpa ‚úîÔ∏è Mais produtivo ‚úîÔ∏è Mais leg√≠vel\nPlugins Essenciais do Pytest pytest-cov Mede cobertura de c√≥digo Ajuda a identificar √°reas n√£o testadas ‚ö†Ô∏è Cobertura alta ‚â† c√≥digo de qualidade\npytest-mock Facilita cria√ß√£o de mocks Reduz boilerplate Boas Pr√°ticas Gerais Testes devem ser simples Um comportamento por teste Nomes claros e descritivos Evite l√≥gica complexa nos testes Testes devem ser determin√≠sticos Conclus√£o Testes automatizados n√£o s√£o um luxo, s√£o uma necessidade profissional. Pytest fornece as ferramentas certas para escrever testes claros, escal√°veis e confi√°veis.\nNo pr√≥ximo post da s√©rie, vamos aplicar todos esses conceitos em um projeto Flask real, consumindo a API p√∫blica do GitHub, com testes unit√°rios, de integra√ß√£o, funcionais e de performance.\nüëâ Continue para o Post 2: Pytest na Pr√°tica com Flask e API do GitHub\n","title":"Testes com Pytest - Fundamentos, Boas Pr√°ticas e Estrat√©gia"},{"link":"/pt/posts/entendendo-mock-e-magicmock-em-python/","text":" Este artigo foi escrito para qualquer pessoa entender (se teve algo que n√£o entendeu me fale, para que possa melhorar), mesmo quem ainda est√° come√ßando com testes em Python. Vamos explicar o que √© cada conceito, por que ele existe e quando usar, sempre com exemplos pr√°ticos e explica√ß√µes claras.\n1. O que √© Mock? (explica√ß√£o simples) Um Mock √© um objeto falso, criado apenas para testes, que finge ser outro objeto real.\nEle permite:\nSimular fun√ß√µes, m√©todos, classes e objetos inteiros Definir retornos e exce√ß√µes Registrar chamadas (quantidade, argumentos, ordem) Isolar a unidade de c√≥digo testada Em vez de usar:\num banco de dados real, uma API externa, um servi√ßo de e-mail, ou um sistema complexo, usamos um mock para simular esse comportamento.\nPor que isso √© importante? Porque em testes n√≥s queremos:\nvelocidade, previsibilidade, isolamento. Exemplo mental Imagine uma fun√ß√£o que envia e-mails:\nPYTHON Recolher Copiar def send_email(to): print(\u0026#34;Enviando email\u0026#34;) Clique para expandir e ver mais Em um teste, voc√™ n√£o quer enviar e-mails de verdade. Ent√£o voc√™ substitui essa fun√ß√£o por um mock.\nO mock:\nn√£o envia nada, mas registra se foi chamado, com quais argumentos, e quantas vezes. üëâ Por isso dizemos que o mock √© flex√≠vel: voc√™ define como ele deve se comportar.\nüëâ Qualquer atributo acessado em um Mock vira automaticamente outro Mock.\n2. O que √© MagicMock? MagicMock √© um tipo especial e subclasse de Mock.\nEle existe para simular objetos que usam m√©todos m√°gicos do Python.\nO que s√£o m√©todos m√°gicos? S√£o m√©todos que:\ncome√ßam e terminam com __ o Python chama automaticamente Exemplos comuns:\n__len__ ‚Üí chamado quando usamos len(obj) __iter__ ‚Üí usado em for __getitem__ ‚Üí usado com obj[x] __contains__ ‚Üí usado com in __str__ ‚Üí usado com print(obj) Esses m√©todos n√£o s√£o chamados diretamente, mas pelo pr√≥prio Python.\nPor que MagicMock existe? O Mock normal n√£o lida bem com esses m√©todos. O MagicMock j√° vem preparado para isso.\n3. Mock ‚â† Stub ‚â† Fake (diferen√ßas importantes) Stub Um stub apenas retorna valores fixos.\nPYTHON Recolher Copiar def get_user_stub(): return {\u0026#34;id\u0026#34;: 1} Clique para expandir e ver mais Fake Um fake tem uma implementa√ß√£o simples, mas funcional.\nPYTHON Recolher Copiar class FakeEmailService: def __init__(self): self.sent = [] def send(self, to): self.sent.append(to) Clique para expandir e ver mais Mock Um mock registra chamadas e valida intera√ß√µes.\nPYTHON Recolher Copiar from unittest.mock import Mock email = Mock() email.send(\u0026#34;a@test.com\u0026#34;) email.send.assert_called_once_with(\u0026#34;a@test.com\u0026#34;) Clique para expandir e ver mais 4. Principais atributos e m√©todos return_value Define o valor retornado pelo mock.\nPYTHON Recolher Copiar mock.func.return_value = 10 Clique para expandir e ver mais side_effect Permite exce√ß√µes, fun√ß√µes ou m√∫ltiplos retornos.\nPYTHON Recolher Copiar mock.func.side_effect = Exception(\u0026#34;Erro\u0026#34;) Clique para expandir e ver mais called / call_count Indicam se e quantas vezes foi chamado.\nPYTHON Recolher Copiar assert mock.func.called assert mock.func.call_count == 1 Clique para expandir e ver mais call_args / call_args_list Mostram os argumentos usados.\nPYTHON Recolher Copiar mock.func(1) mock.func(2) assert mock.func.call_args_list == [((1,),), ((2,),)] Clique para expandir e ver mais 5. patch ‚Äî substituindo depend√™ncias Use patch para trocar depend√™ncias reais por mocks temporariamente.\nA regra de ouro:\nVoc√™ deve patchar onde o objeto √© USADO, n√£o onde √© DEFINIDO.\nPYTHON Recolher Copiar # app/services.py from app.email import send_email def notify(user): send_email(user.email) Clique para expandir e ver mais PYTHON Recolher Copiar with patch(\u0026#34;app.services.send_email\u0026#34;) as mock_send: notify(user) Clique para expandir e ver mais ‚ùå ERRADO:\nPYTHON Recolher Copiar patch(\u0026#34;app.email.send_email\u0026#34;) Clique para expandir e ver mais 6. spec e autospec Use para evitar erros silenciosos e garantir assinatura correta.\nspec Restringe atributos v√°lidos.\nPYTHON Recolher Copiar mock = Mock(spec=MyClass) Clique para expandir e ver mais autospec Restringe atributos e assinatura.\nPYTHON Recolher Copiar @patch(\u0026#34;module.func\u0026#34;, autospec=True) def test(mock_func): ... Clique para expandir e ver mais ‚úÖ Evita erros silenciosos.\n7. Mock com l√≥gica ‚Üí use Fake Se o mock cont√©m l√≥gica complexa, transforme-o em um fake.\n8. Problemas comuns e como resolver ‚ùå Mock n√£o funciona ‚û°Ô∏è Patch no lugar errado\n‚ùå Teste passa mas quebra em produ√ß√£o ‚û°Ô∏è Falta de autospec\n‚ùå Teste dif√≠cil de entender ‚û°Ô∏è Mocks demais\n‚ùå Mock com l√≥gica ‚û°Ô∏è Extraia para fake\n9. Quando usar (e quando N√ÉO usar) Use mocks quando: H√° chamadas HTTP H√° acesso a banco de dados H√° leitura/escrita de arquivos H√° servi√ßos externos H√° depend√™ncias dif√≠ceis de reproduzir N√ÉO use mocks quando: Voc√™ est√° testando l√≥gica pura O teste vira uma c√≥pia da implementa√ß√£o O mock come√ßa a ter l√≥gica pr√≥pria Regra pr√°tica: mock depend√™ncias, n√£o regras de neg√≥cio.\n10. Boas pr√°ticas reais Use autospec=True Mock menos, teste mais comportamento Nomeie bem seus mocks Um teste, um cen√°rio 11. Anti‚Äëpadr√µes üö´ Mockar m√©todo privado\nüö´ Mockar l√≥gica de dom√≠nio\nüö´ Testar apenas chamadas\nüö´ Mocks aninhados em excesso\n12. Checklist mental Antes de criar um mock:\nIsso √© uma depend√™ncia externa? Esse teste precisa mesmo disso? Um fake seria mais simples? Estou testando comportamento ou implementa√ß√£o? Refer√™ncias https://docs.python.org/3/library/unittest.mock.html ","title":"Entendendo Mock e MagicMock em Python"}],"tags":[{"link":"/pt/tags/mock/","name":"Mock","slug":"Mock"},{"link":"/pt/tags/pytest/","name":"Pytest","slug":"Pytest"},{"link":"/pt/tags/python/","name":"Python","slug":"Python"},{"link":"/pt/tags/tests/","name":"Tests","slug":"Tests"},{"link":"/pt/tags/unittest/","name":"Unittest","slug":"Unittest"}]}